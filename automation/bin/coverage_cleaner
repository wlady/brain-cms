#!/usr/bin/php
<?php

include __DIR__.'/../../engine/bootstrap.php';

use PhpParser\ParserFactory;
use PhpParser\NodeTraverser;
use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;

class PHPCodeNodeVisitor extends NodeVisitorAbstract
{
    protected static $cache = null;

    public function __construct($cache) {
        self::$cache = $cache;
    }

    public function leaveNode(Node $node) {
        if ($node instanceof PhpParser\Node\Stmt) {
            $attrs = $node->getAttributes();
            if (isset($attrs['startLine']) && isset($attrs['endLine']) && $attrs['startLine']!=$attrs['endLine']) {
                $endLines = self::$cache->get('endLines');
                $endLines[] = $attrs['endLine'];
                self::$cache->set('endLines', $endLines);
            }
        }
    }
}

$usage = <<<EOUsage

Coverage Dead Code Cleaner by Vladimir Zabara <wlady@konturlabs.com> (Oct 26, 2015)

Usage: coverage_cleaner [options]

Options are:
    --input=filename            (requiered) PHP_CodeCoverafe_Report_PHP is file generated by
                                PHPunit by --coverage-php option
    --coverage-clover=filename  (optional) Output coverage file in Clover format.
                                Use this option insetad of standard PHPUnit --coverage-clover
    --coverage-html=dir         (optional) Output directory where code coverage report will be generated.
                                Use this option insetad of standard PHPUnit --coverage-html

EOUsage;

$shortopts = '';
$longopts = [
    'input:',
    'coverage-clover::',
    'coverage-html::',
];
$options = getopt($shortopts, $longopts);

if (!is_file($options['input'])) {
    die($usage);
}
$coverage = include $options['input'];
if (empty($coverage)) {
    die($usage);
}

$cacheClass = '\Bump\Cache\Memcached';
try {
    if (class_exists($cacheClass)) {
        $cache = new $cacheClass();
    }
} catch (\Exception $e) {
    $cache = null;
}

if (!$cache) {
    $cache = new \Bump\Cache\File();
}

$parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);
$traverser = new NodeTraverser;
$traverser->addVisitor(new PHPCodeNodeVisitor($cache));

$coverageData = $coverage->getData();
foreach ($coverageData as $file => &$data) {
    // parse source file
    $stmts = $parser->parse(file_get_contents($file));
    $cache->set('endLines', []);
    // collect 'endLines'
    $stmts = $traverser->traverse($stmts);
    // clean
    $data = array_filter($data, function($item, $line) use ($cache) {
        // empty array is a non covered line
        if (is_array($item)) {
            return true;
        }
        // non empty array is covered line
        if (!empty($item)) {
            return true;
        }
        // empty but not in 'endLines' - really dead line
        if (!in_array($line, $cache->get('endLines'))) {
            return true;
        }
        // other empty line should be removed
        return false;
        // return is_array($item) ? true : !empty($item);
    }, ARRAY_FILTER_USE_BOTH);
}
$coverage->setData($coverageData);
$writer = new PHP_CodeCoverage_Report_PHP;
$writer->process($coverage, $options['input']);
if (!empty($options['coverage-clover'])) {
    echo "Generating code coverage report in Clover format\n";
    $writer = new PHP_CodeCoverage_Report_Clover;
    $writer->process($coverage, $options['coverage-clover']);
}
if (!empty($options['coverage-html'])) {
    echo "Generating code coverage report in HTML format\n";
    $writer = new PHP_CodeCoverage_Report_HTML;
    $writer->process($coverage, $options['coverage-html']);
}
echo "Done\n";
